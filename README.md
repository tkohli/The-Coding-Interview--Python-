# The Coding Interview (Python)
This is new repository in which we will first make a map and then follow it in order to complete all required topic in Programming interviews.
## Getting Started
We will start by first defining the scope of this repo.<br>
We will cover Data structure, Algorithms and Programming Concepts.
| Data structure      | Algorithms | Programming Concepts     |
| :---        |    :----:   |          ---: |
| Array and lists     |  Quick Sort  | Big O Time & Space |
| Stacks & Queues      | Binary Search      |   Recursion    |
| Linked Lists    | Merge Sort       | Bit Manipulation  |
| Heaps      |    Breadth-First Search   |     Dynamic Programming  |
| Trees,  Graphs   | Depth-First Search       | Memory (Stack vs. Heap)      |


And also hash tables.<br>
This is just a categorization and not the syllabus so yes topics are not written here.

## Walking Through a Problem - The Thinking Process
This is one of the most underrated process that I generally mess-up. So I am just gonna clarify
all the things to keep in mind and also the process that we should use<br>
Note - This is more like a stater bundle I would recommend to improvise it more and more.<br>
#### 1. Reading the problem statement 
Note all important data that can be extracted from that problem, we will need each and every bit of that data.
#### 2. Example or Sample Test Cases
This is the part which helps us thinking, and tells us how the program should run.<br>
We can end up finding some cool pattern hidden in solved examples if we play close attention.
#### 3. Brute Force 
Coming up with more basic and naive solution helps us in breaking the problem and works as our first milestone. This step is more important for beginners (including me) as we can find more insights after solving this problem.
#### 4. Optimization
The is the part for which we all are working. Solving a problem is not a that big challenge optimizing it, is. take this as a heart of DSA your whole life depends on it.<br>    
So how we do this 
<ol>
<li>Reduce the unnecessary code and space.</li>
<li>Check for bottlenecks</li>
<li>Remove duplication</li>
<li>Reverse engineer the thought process and think about another ways this can be solved</li>
</ol>
This process takes time and you will become more and more comfortable by solving new problems.

#### 5. WalkThrough
Now take some test case and try running them into your solution.

#### 6. Implementation 
After all this work all you have to do is write a beautiful code, and modularize all things you have done till now.
#### 7. Test
Testing your final solution by some small test cases, some big test case, and also edge cases to be very sure about your.
<br>
So now we have a complete solution for our problem, you always modify this process to be more effective but, this is what I recommend all new comers to go through.

## Syllabus
### Data Structures
| Data Structure | Content |
|----------------------|--------------------------|
| Array or List & Strings | <ul>  <li>- [ ] Insertion, Deletion, Updation</li><li>- [ ] Multi-dimensional</li><li>- [ ] Strings</li><li>- [ ] Hash tables</li></ul>|
| Linked List     | <ul>  <li>- [ ] Insertion, Deletion, Updation at given position</li><li>- [ ] Circular linked list</li><li>- [ ] Double linked list</li></ul>|
| Stacks and Queues    | <ul>  <li>- [ ] Insertion, Deletion, Updation of both stack and queue</li><li>- [ ] Implementing a Stack</li><li>- [ ] Implementing a Queue</li></ul>|
| Trees and Graphs    | <ul>  <li>- [ ] Insertion, Deletion, Updation of tree and graph</li><li>- [ ] Types of Trees</li><li>- [ ] Binary Tree Traversal</li><li>- [ ] Binary Heaps (Min-Heaps and Mox-Heaps)</li><li>- [ ] Types of Graph </li><li>- [ ] Graph traversal</li><li>- [ ] Graph Searching</li></ul>|


### Algorithm and concept
| Algorithms and concept | Content |
|----------------------|--------------------------|
| Bit Manipulation| <ul>  <li>- [ ] Bit Facts and Tricks</li><li>- [ ] Two's Complement and Negative Numbers .</li><li>- [ ] Common Bit Tasks: Getting and Setting</li><li>- [ ] more problems</li></ul>|
| Recursion and Dynamic Programming     | <ul>  <li>- [ ] Dynamic Programming & Memoization</li><li>- [ ] Recursive vs. Iterative Solutions</li></ul>|
| Searching    | <ul>  <li>- [ ] Linear Search</li><li>- [ ] Binary Search</li></ul>|
| Sorting   | <ul>  <li>- [ ] Bubble Sort</li><li>- [ ] Selection Sort</li><li>- [ ] Insertion Sort</li><li>- [ ] Merge Sort</li><li>- [ ] Quick Sort</li><li>- [ ] Heap Sort</li></ul>|
| Graphs   | <ul>  <li>- [ ] Graph Representation</li><li>- [ ] Breadth First Search</li><li>- [ ] Depth First Search</li><li>- [ ] Minimum Spanning Tree</li><li>- [ ] Shortest Path Algorithms</li><li>- [ ] Hamiltonian Path</li><li>- [ ] Maximum flow</li><li>- [ ] Minimum Cost Maximum Flow</li></ul>|


# Resources
https://www.hackerearth.com/practice/
<br>
More resources will be added while working on them.
